# -*- coding: utf-8 -*-
"""8Tile.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NnMYpiP4lyH0AoOVgSHVCo3-hBXjHjg7
"""
import numpy as np
class Solve8:
  def __init__(self):
    self.goal_state = np.array(([1, 2, 3], [4, 5, 6], [7, 8, 0]))

  def __str__(self):
    return 'The first rule of Kaybedenler Club...Never mind'


  def heuristic(self, state):
    distance = 0
    goal = self.goal_state
    difference = state - goal
    index = np.nonzero(difference)
    for i in range(np.count_nonzero(difference)):
        row = index[0][i]
        col = index[1][i]
        value = state[row][col]
        if value != 0:
            row_goal, col_goal = np.where(goal == value)
            distance += abs(row - row_goal) + abs(col - col_goal)
    return int(distance)

  def node_gen(self, board):
    nodes = []
    moves = []
    zero_positions = np.argwhere(board == 0)
    row, col = zero_positions[0]
    mvs2apply = [[-1, 0], [1, 0], [0, -1], [0, 1]]

    for move in mvs2apply:
        node_col, node_row = col + move[1], row + move[0]
        if 0 <= node_row <= 2 and 0 <= node_col <= 2:
            node = board.copy()
            node[row, col], node[node_row, node_col] = node[node_row, node_col], 0
            nodes.append(node)
            moves.append(move)

    return nodes, moves

  def Solve(self,Tile):
    board = Tile.Board
    goal_state = self.goal_state
    queue = [(0, board, [], 0)]  # [hn, board, location, gn]
    visited = {}

    while queue:
        queue.sort(key=lambda x: 1.02 * x[0] + x[3])
        cost_val, current_state, location, fix_cost = queue.pop(0)

        if np.array_equal(current_state, goal_state):
            return location

        if visited.setdefault(tuple(current_state.flatten()), False):
            continue

        visited[tuple(current_state.flatten())] = True
        nodes, moves = self.node_gen(current_state)
        fix_cost += 1

        for i, node in enumerate(nodes):
            move = location + [moves[i]]
            node_cost = self.heuristic(node)
            queue.append((node_cost, node, move, fix_cost))
    return None